# 七、Resource Management

# 1.章节介绍和范围

在多任务系统中，如果一个任务开始访问资源，但在退出运行状态之前未完成其访问，则可能会出错。 如果任务使资源处于不一致状态，则任何其他任务或中断对同一资源的访问可能会导致数据损坏或其他类似问题。

资源被抢占的例子：

1. 访问外设
任务在访问一个外设的过程中可能被打断，且打断的任务同时又访问了这个外设，从而发生错误。
2. 执行读、修改、写操作（非原子的）
由于读写操作是非原子的，可能在未完成的情况下被中断或者更高优先级的任务打断，同时在新任务或者中断中被操作，导致资源发生错误。
3. 非原子的方式访问变量
更新结构体内的多个成员，或者更新大于架构字长的变量都是非原子操作。如果在更新过程中被打断，可能导致数据丢失或损坏。
4. 函数重载
如果从多个任务或从任务和中断都调用函数是安全的，则函数是“可重入的”。 可重入函数被认为是“线程安全的”，因为它们可以从多个执行线程访问，而不会有数据或逻辑操作被破坏的风险。
每个任务都维护自己的堆栈和自己的一组处理器（硬件）寄存器值。 ***如果一个函数不访问存储在堆栈中或保存在寄存器中的数据以外的任何数据，则该函数是可重入的，并且是线程安全的。***
简单而言就是函数是否有访问非自身heap的内容。如果没有，则函数是可重入的，否则相反。

## 互斥描述

为了确保始终保持数据一致性，对任务之间或任务和中断之间共享的资源的访问必须使用“互斥”技术进行管理。 目标是确保一旦任务开始访问不可重入且非线程安全的共享资源，同一任务对资源具有独占访问权，直到资源返回到可持续状态。

FreeRTOS 提供了一些可用于实现互斥的功能，但最好的互斥方法是（尽可能地，因为它通常不切实际）设计的应用不共享资源，而且每个资源只能被单个任务访问。

## 本章范围

- 何时以及为何需要资源管理和控制。
- 什么是临界区。
- 互斥意味着什么。
- 挂起调度器意味着什么。
- 如何使用互斥锁。
- 如何创建和使用看门人任务。
- 什么是优先级反转，以及优先级继承如何减少（但不能消除）其影响。

# 2. 临界区和挂起调度器

## 基本临界区

基本临界区是分别被宏 taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 调用包围的代码区域。 Critical sections也称为Critical regions。

taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 不带任何参数，或返回值。

在调用 taskENTER_CRITICAL() 和调用 taskEXIT_CRITICAL() 之间不能切换到另一个任务。 只有逻辑优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 常量的值的中断仍然可以执行，但不允许这些中断调用 FreeRTOS API 函数。

以这种方式实现的关键部分是提供互斥的一种非常粗略的方法。它们的工作方式是完全禁用中断，或者禁用中断优先级（由 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置），具体取决于所使用的 FreeRTOS 端口。抢先式上下文切换只能在中断中发生，因此，只要中断保持禁用状态，调用 taskENTER_CRITICAL() 的任务就可以保证保持在运行状态，直到退出临界区。

基本临界区必须保持非常短，否则它们会对中断响应时间产生不利影响。对 taskENTER_CRITICAL() 的每次调用都必须与对 taskEXIT_CRITICAL() 的调用紧密配对。因此，不应使用临界区保护标准输出（stdout，或计算机写入其输出数据的流），因为写入终端可能是一个相对较长的操作。

临界区嵌套是安全的，因为内核会计算嵌套深度。 只有当嵌套深度归零时，临界区才会退出——即对于之前对 taskENTER_CRITICAL() 的每个调用都执行了一次 taskEXIT_CRITICAL() 调用。

***调用 taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 是任务更改运行 FreeRTOS 的处理器的中断启用状态的唯一合法方法。 通过任何其他方式更改中断使能状态将使宏的嵌套计数无效。***

taskENTER_CRITICAL_FROM_ISR() 是 taskENTER_CRITICAL() 的中断安全版本，taskEXIT_CRITICAL_FROM_ISR() 是 taskEXIT_CRITICAL() 的中断安全版本。 中断安全版本仅提供给允许中断嵌套的 FreeRTOS 端口——它们在不允许中断嵌套的端口中被禁用。

taskENTER_CRITICAL_FROM_ISR() 返回一个值，该值必须传递到对 taskEXIT_CRITICAL_FROM_ISR() 的匹配调用中。如下所示：

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled.png)

“使用更多的处理时间来执行进入和退出临界区代码，而不是执行实际受临界区保护的代码” 这非常浪费。基本临界区进入和退出的速度非常快，且始终具有确定性。因此当受保护的代码段非常短时，非常适合使用它们。

## 挂起或者锁定调度器

也可以通过挂起调度器来创建关键部分。挂起调度器有时也称为“锁定”调度器。
基本临界区保护代码区域不被其他任务和中断访问。 通过挂起调度器实现的临界区仅保护代码区域不被其他任务访问，但中断可以访问。

临界区太长而无法通过简单地禁用中断来实现，相反，可以通过挂起调度器来实现。 但是中断活动会使调度器从挂起到恢复的操作变得相对较长，因此必须考虑在每种情况下使用哪种方法最好。

### vTaskSuspendAll()

```c
/*
	调度器通过调用 vTaskSuspendAll() 被挂起。 暂停调度器可防止发生上下文
切换，但会启用中断。 如果在调度器挂起时中断请求上下文切换，则该请求将保
持挂起，并且仅在调度器恢复（未挂起）时执行。
调度器挂起时不得调用 FreeRTOS API 函数。
*/
void vTaskSuspendAll( void );
```

### xTaskResumeAll()

```c
/*
	恢复调度器

Return:
	调度程序挂起时请求的上下文切换保持挂起状态，仅在调度程序恢复时执行。 
	pdTRUE - 在 xTaskResumeAll() 返回之前执行了挂起的上下文切换
	pdFALSE - 相反
*/
BaseType_t xTaskResumeAll( void );
```

对 vTaskSuspendAll() 和 xTaskResumeAll() 的调用嵌套是安全的，因为内核会计算嵌套深度。 仅当嵌套深度返回零时，调度程序才会恢复——即对于之前对 vTaskSuspendAll() 的每个调用都执行了一次 xTaskResumeAll() 调用。

# 3. 互斥锁（二进制信号量）

互斥锁是一种特殊类型的二进制信号量，用于控制对两个或多个任务之间共享的资源的访问。 MUTEX 一词源于“互斥”。 configUSE_MUTEXES 必须在 FreeRTOSConfig.h 中设置为 1 才能使用互斥锁。

在互斥场景中使用互斥锁时，可以将互斥锁视为与共享资源相关联的令牌。 对于合法访问资源的任务，它必须首先成功“获取”令牌（成为令牌持有者）。 当令牌持有者用完资源后，它必须“返还”令牌。 只有当令牌被返回后，另一个任务才能成功获取令牌，然后安全地访问相同的共享资源。 除非任务持有令牌，否则不允许任务访问共享资源。 这种机制如图 63 所示：

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled%201.png)

尽管互斥体和二进制信号量共享许多特性，但图 63 中所示的场景（其中互斥体用于互斥）与[图 53](%E5%85%AD%E3%80%81Interrup%2033926.md) 中所示的场景（其中二进制信号量用于同步）完全不同。 主要区别在于信号量在获得后会发生什么：

- 用于互斥的信号量用完必须返回。
- 用于同步的信号量通常被丢弃且不返回。

互斥锁机制纯粹通过程序员的自律来工作。没有理由让任务在任何时候都无法访问资源，但每个任务都“同意”不这样做，除非它能够成为互斥锁持有者。

## xSemaphoreCreateMutex()

```c
/*
Return:
	NULL - 由于heap不够创建互斥锁的数据结构而创建失败。
	non-NULL - 创建成功，返回互斥锁的句柄。
*/
SemaphoreHandle_t xSemaphoreCreateMutex( void );
```

使用同二进制信号量一样的函数来take和give互斥锁：

- [xSemaphoreTake](%E5%85%AD%E3%80%81Interrup%2033926.md)(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)
- [xSemaphoreGive](%E5%85%AD%E3%80%81Interrup%2033926.md)(SemaphoreHandle_t xSemaphore)

## 优先级反转

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled%202.png)

上图展示了使用互斥体提供互斥的潜在缺陷之一。 所描述的执行顺序显示了较高优先级的任务 2 必须等待较低优先级的任务 1 放弃对互斥体的控制。 ***以这种方式被较低优先级任务延迟的较高优先级任务称为“优先级反转”***。 如果中等优先级任务开始执行而高优先级任务正在等待信号量（结果将是高优先级任务等待低优先级任务），则这种不良行为将被进一步夸大，而低优先级任务甚至无法执行。 这种最坏的情况如图 66 所示。

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled%203.png)

***优先级反转可能是一个重大问题，但在小型嵌入式系统中，通常可以在系统设计时通过考虑如何访问资源来避免它。***

## 优先级继承

FreeRTOS 互斥体和二进制信号量非常相似——不同之处在于互斥体包含基本的“优先级继承”机制，而二进制信号量则没有。 **优先级继承是一种将优先级倒置的负面影响降至最低的方案。 它不会“修复”优先级倒置，而只是通过确保倒置总是有时间限制来减轻其影响。** 但是，优先级继承使系统时序分析变得复杂，依赖它来进行正确的系统操作并不是一个好的做法。

优先级继承的工作原理是将互斥锁持有者的优先级临时提高到试图获得相同互斥锁的最高优先级任务的优先级。 持有互斥锁的低优先级任务“继承”等待互斥锁的任务的优先级。 图 67 演示了这一点。互斥锁持有者的优先级在归还互斥锁时自动重置为其原始值。

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled%204.png)

**如前所述，优先级继承功能会影响使用互斥锁的任务的优先级。 因此，不能在中断服务例程中使用互斥锁。**

## 死锁 （or Deadly Embrace）

“死锁”是使用互斥锁进行互斥的另一个潜在陷阱。

当两个任务因为都在等待对方持有的资源而无法继续时，就会发生死锁。 考虑以下场景，其中任务 A 和任务 B 都需要获取互斥锁 X 和互斥锁 Y 才能执行操作：

1. 任务 A 执行并成功获取 互斥锁X。
2. 任务 A 被任务 B 抢占。
3. 任务 B 在尝试也获取互斥锁 X 之前成功地获取了互斥锁 Y——但互斥锁 X 由任务 A 持有，因此对任务 B 不可用。任务 B 选择进入阻塞状态以等待互斥锁 X 被释放。
4. 任务A继续执行。 它尝试获取互斥体 Y，但互斥体 Y 由任务 B 持有，因此对任务 A 不可用。任务 A 选择进入阻塞状态以等待互斥体 Y 被释放。

在这个场景结束时，任务 A 正在等待任务 B 持有的互斥锁，而任务 B 正在等待任务 A 持有的互斥锁。由于两个任务都无法继续，因此发生了死锁。

与优先级倒置一样，避免死锁的最佳方法是在设计时考虑其可能性，并设计系统以确保不会发生死锁。 特别是，正如本书前面所述，任务无限期地等待（没有超时）以获得互斥锁通常是不好的做法。 相反，使用比预期必须等待互斥锁的最长时间稍长的超时时间——那么在该时间内未能获得互斥锁将是设计错误的征兆，这可能是死锁。

在实践中，死锁在小型嵌入式系统中并不是什么大问题，因为系统设计人员可以很好地了解整个应用程序，从而可以识别和消除可能发生死锁的区域。

## 递归互斥锁

任务也可能与自身发生死锁。 如果一个任务尝试多次使用同一个互斥锁，而不首先返回互斥锁，就会发生这种情况。 考虑以下场景：

1. 任务成功获取互斥量。
2. 在持有互斥锁的同时，任务调用库函数。
3. 库函数的实现尝试取同一个互斥体，进入阻塞状态等待互斥体可用。

在这个场景结束时，任务处于阻塞状态等待互斥锁返回，但任务已经是互斥锁持有者。 发生死锁是因为任务处于阻塞状态等待自己。

可以通过使用递归互斥锁代替标准互斥锁来避免这种类型的死锁。 递归互斥锁可以被同一个任务多次“获取”，并且只有在对“获取”递归互斥锁的每个先前调用都执行了一次“给予”递归互斥锁的调用后才会返回。

标准互斥锁和递归互斥锁的创建和使用方式类似：

- 使用 xSemaphoreCreateMutex() 创建标准互斥锁。 递归互斥锁是使用 xSemaphoreCreateRecursiveMutex() 创建的。 这两个 API 函数具有相同的原型。
- 使用 xSemaphoreTake()“taken”标准互斥锁。 递归互斥锁是使用 xSemaphoreTakeRecursive() 来“taken”的。 这两个 API 函数具有相同的原型。
- 使用 xSemaphoreGive() “given”标准互斥锁。 递归互斥锁是使用 xSemaphoreGiveRecursive() “given”的。 这两个 API 函数具有相同的原型。

## 互斥锁和任务调度

如果两个不同优先级的任务使用同一个互斥锁，那么 FreeRTOS 调度策略会明确任务执行的顺序； 能够运行的优先级最高的任务将被选为进入运行状态的任务。 例如，如果一个高优先级任务处于阻塞状态以等待一个低优先级任务持有的互斥锁，那么一旦低优先级任务返回互斥锁，高优先级任务就会抢占低优先级任务。然后，高优先级任务将成为互斥锁持有者。 这种情况已经在[图 67](%E4%B8%83%E3%80%81Resource%20caadc.md) 中看到。

当时如果任务具有相同优先级时，通常会估计错误任务的执行顺序。 如果 Task 1 和 Task 2 具有相同的优先级，并且 Task 1 处于 Blocked 状态以等待 Task 2 持有的互斥锁，那么当 Task 2“给予”互斥锁时，Task 1 不会抢占 Task 2。 相反，任务 2 将保持在运行状态，而任务 1 将简单地从阻塞状态移动到就绪状态。 这种情况如图 68 所示，其中垂直线标记发生滴答中断的时间。

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled.jpeg)

在图 68 所示的场景中，一旦互斥锁可用，FreeRTOS 调度程序就不会使任务1 成为运行状态任务，因为：

1. 任务 1 和任务 2 具有相同的优先级，因此除非任务 2 进入 Blocked 状态，否则在下一个滴答中断之前不应切换到任务 1（假设 FreeRTOSConfig.h 中的 configUSE_TIME_SLICING 设置为 1）。
2. 如果任务在紧密循环中使用互斥锁，并且每次任务“given”互斥锁时都会发生上下文切换，那么任务只会在短时间内保持运行状态。 如果两个或多个任务在紧密循环中使用相同的互斥锁，则在任务之间快速切换会浪费处理时间。

如果多个任务在紧密循环中使用互斥锁，并且使用互斥锁的任务具有相同的优先级，则必须注意确保接收任务的处理时间大致相同。 图 69 展示了任务可能无法获得等量处理时间的原因，该图显示了如果以相同优先级创建清单 125 所示任务的两个实例时可能发生的执行序列。

![Untitled](%E4%B8%83%E3%80%81Resource%20caadc/Untitled%205.png)

图 69 中的第 7 步显示任务 1 重新进入阻塞状态 — 这发生在 xSemaphoreTake() API 函数内部。
图 69 展示了任务 1 将被阻止获取互斥锁，直到时间片的开始与任务 2 不是互斥锁持有者的短周期之一重合。
通过在调用 xSemaphoreGive() 之后添加对 taskYIELD() 的调用，可以避免图 69 中所示的情况。

# 4. Gatekeeper Tasks(看门人任务)

看门人任务提供了一种干净的方法来实现互斥，而不会出现优先级反转或死锁的风险。
看门人任务是对资源拥有唯一所有权的任务。 只有看门人任务被允许直接访问资源——任何其他需要访问资源的任务只能通过使用看门人任务的服务间接访问。

在某些情况下，为看门人任务分配更高的优先级是合适的，因此消息会立即得到处理——但这样做的代价是看门人任务使延迟较低优先级的任务，直到它完成对受保护资源的访问。